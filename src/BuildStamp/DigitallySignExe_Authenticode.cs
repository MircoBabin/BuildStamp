using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;

namespace BuildStamp
{
    public class DigitallySignExe_Authenticode
    {
        private static class NativeMethods
        {
            /* Partially copied from https://github.com/dahall/Vanara
             * https://github.com/dahall/Vanara/blob/master/PInvoke/Cryptography/CryptUI/Wincrypt.cs
               MIT License

               Copyright (c) 2017 David Hall

               Permission is hereby granted, free of charge, to any person obtaining a copy
               of this software and associated documentation files (the "Software"), to deal
               in the Software without restriction, including without limitation the rights
               to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
               copies of the Software, and to permit persons to whom the Software is
               furnished to do so, subject to the following conditions:

               The above copyright notice and this permission notice shall be included in all
               copies or substantial portions of the Software.

               THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
               IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
               FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
               AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
               LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
               OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
               SOFTWARE.
             */

            [Flags]
            public enum CryptUIWizFlags : uint
            {
                /// <summary>
                /// This function will sign the document based on the information in the CRYPTUI_WIZ_DIGITAL_SIGN_INFO structure pointed to by
                /// the pDigitalSignInfo parameter without displaying any user interface. If this flag is not specified, this function will
                /// display a wizard to guide the user through the signing process.
                /// </summary>
                CRYPTUI_WIZ_NO_UI = 0x0001,

                /// <summary>
                /// Suppress all user interfaces generated by cryptographic service providers (CSPs). This option can be overridden by the
                /// CRYPTUI_WIZ_NO_UI_EXCEPT_CSP option.
                /// </summary>
                CRYPTUI_WIZ_IGNORE_NO_UI_FLAG_FOR_CSPS = 0x0002,

                /// <summary>
                /// Suppress all user interfaces except those generated by CSPs. This option overrides the
                /// CRYPTUI_WIZ_IGNORE_NO_UI_FLAG_FOR_CSPS option.
                /// </summary>
                CRYPTUI_WIZ_NO_UI_EXCEPT_CSP = 0x0003,

                /// <summary>Skip the Export Private Key page and assume that the private key is to be exported.</summary>
                CRYPTUI_WIZ_EXPORT_PRIVATE_KEY = 0x0100,

                /// <summary>Disable the Delete the private key check box in the Export File Format page.</summary>
                CRYPTUI_WIZ_EXPORT_NO_DELETE_PRIVATE_KEY = 0x0200,

                /// <summary>Allow certificates to be imported.</summary>
                CRYPTUI_WIZ_IMPORT_ALLOW_CERT = 0x00020000,

                /// <summary>Allow CRLs to be imported.</summary>
                CRYPTUI_WIZ_IMPORT_ALLOW_CRL = 0x00040000,

                /// <summary>Allow CTLs to be imported.</summary>
                CRYPTUI_WIZ_IMPORT_ALLOW_CTL = 0x00080000,

                /// <summary>Do not allow the user to change the destination certificate store represented by the hDestCertStore parameter.</summary>
                CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE = 0x00010000,

                /// <summary>
                /// Import the object to the certificate store for the local computer. This applies only to Personal Information Exchange (PFX) imports.
                /// </summary>
                CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE = 0x00100000,

                /// <summary>Import the object to the certificate store for the current user. This applies only to PFX imports.</summary>
                CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER = 0x00200000,

                /// <summary>
                /// Import the object to a remote certificate store. Set this flag if the hDestCertStore parameter represents a remote
                /// certificate store.
                /// </summary>
                CRYPTUI_WIZ_IMPORT_REMOTE_DEST_STORE = 0x00400000,
            }

            [Flags]
            public enum CryptUIWizSigType
            {
                /// <summary>The signature is a commercial signature.</summary>
                CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL = 0x01,

                /// <summary>The signature is a personal signature.</summary>
                CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL = 0x02,
            }

            [StructLayout(LayoutKind.Sequential)]
            public struct CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO
            {
                /// <summary>The size, in bytes, of the structure.</summary>
                public uint dwSize;

                /// <summary>
                /// <para>A value that indicates the type of the signature.</para>
                /// </summary>
                public CryptUIWizSigType dwAttrFlags;

                /// <summary>A pointer to a null-terminated Unicode string that contains the description of the subject of the signature.</summary>
                [MarshalAs(UnmanagedType.LPWStr)] public string pwszDescription;

                /// <summary>
                /// A pointer to a null-terminated Unicode string that contains the location from which to get more information about the file.
                /// This information will be displayed when the file is downloaded.
                /// </summary>
                [MarshalAs(UnmanagedType.LPWStr)] public string pwszMoreInfoLocation;

                /// <summary>
                /// A pointer to a null-terminated ANSI string that contains the object identifier (OID) of the hash algorithm used for the
                /// signature. The default value is <c>NULL</c>, which indicates that the SHA-1 hash algorithm is used.
                /// </summary>
                [MarshalAs(UnmanagedType.LPStr)] public string pszHashAlg;

                /// <summary>
                /// A pointer to a null-terminated Unicode string that contains the string displayed on the digital signature wizard page. The
                /// string should prompt the user to select a certificate for a specific purpose.
                /// </summary>
                [MarshalAs(UnmanagedType.LPWStr)] public string pwszSigningCertDisplayString;

                /// <summary>A handle to an additional certificate store that will be added to the signature.</summary>
                public IntPtr hAdditionalCertStore;

                /// <summary>A pointer to a CRYPT_ATTRIBUTES structure that contains authenticated attributes supplied by the user.</summary>
                public IntPtr psAuthenticated;

                /// <summary>A pointer to a CRYPT_ATTRIBUTES structure that contains unauthenticated attributes supplied by the user.</summary>
                public IntPtr psUnauthenticated;
            }

            [StructLayout(LayoutKind.Sequential)]
            public struct CRYPTUI_WIZ_DIGITAL_SIGN_INFO
            {
                public UInt32 dwSize;

                public CryptUIWizToSign dwSubjectChoice;
                public enum CryptUIWizToSign : UInt32
                {
                    /// <summary>The user will be prompted for a file to sign.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_PROMPT = 0,

                    /// <summary>The memory BLOB specified by the pSignBlobInfo member is to be signed.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE = 0x01,

                    /// <summary>The file specified by the pwszFileName member is to be signed.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB = 0x02,
                }

                /* [MarshalAs(UnmanagedType.LPWStr)] public string pwszFileName;
                 * public IntPtr pSignBlobInfo; // CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO
                 */
                public IntPtr Subject;

                public CryptUIWizSignLoc dwSigningCertChoice;
                public enum CryptUIWizSignLoc : UInt32
                {
                    /// <summary>The certificates in the My store are used.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_USE_MY_STORE = 0x0,

                    /// <summary>The certificate is contained in the CERT_CONTEXT structure pointed to by the pSigningCertContext member.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_CERT = 0x01,

                    /// <summary>
                    /// The certificate is contained in the certificate store contained in the CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO structure pointed
                    /// to by the pSigningCertStore member.
                    /// </summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_STORE = 0x02,

                    /// <summary>
                    /// The certificate is contained in the PVK file contained in the CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO structure pointed to by
                    /// the pSigningCertPvkInfo member.
                    /// </summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_PVK = 0x03,
                }

                public IntPtr pSigningCertObject;

                [MarshalAs(UnmanagedType.LPWStr)]
                public string pwszTimestampURL;

                public CryptUIWizAddChoice dwAdditionalCertChoice;
                public enum CryptUIWizAddChoice
                {
                    /// <summary>No additional certificates will be included in the signature.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_ADD_NONE = 0x0,

                    /// <summary>The entire certificate chain will be included in the signature.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN = 0x00000001,

                    /// <summary>All certificates in the certificate chain except the root will be included in the signature.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT = 0x00000002,
                }

                /// <summary>
                /// A pointer to a CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO structure that contains extended information about the signature.
                /// </summary>
                public IntPtr pSignExtInfo;
            }

            [StructLayout(LayoutKind.Sequential)]
            public struct CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT
            {
                /// <summary>The size, in bytes, of the structure.</summary>
                public UInt32 dwSize;

                /// <summary>The size, in bytes, of the BLOB pointed to by the <c>pbBlob</c> member.</summary>
                public UInt32 cbBlob;

                /// <summary>A pointer to the signed BLOB.</summary>
                public IntPtr pbBlob;
            }

            [DllImport("Cryptui.dll", CharSet = CharSet.Unicode, SetLastError = true, ExactSpelling = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool CryptUIWizDigitalSign(
                CryptUIWizFlags dwFlags,
                [In, Optional] IntPtr hwndParent,
                [Optional, MarshalAs(UnmanagedType.LPWStr)] string pwszWizardTitle,
                /* CRYPTUI_WIZ_DIGITAL_SIGN_INFO */ IntPtr pDigitalSignInfo,
                out IntPtr ppSignContext);

            [DllImport("Cryptui.dll", CharSet = CharSet.Unicode, SetLastError = true, ExactSpelling = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool CryptUIWizFreeDigitalSignContext(IntPtr pSignContext);
            //
            // End: Partially copied from https://github.com/dahall/Vanara
            //
        }

        private class CryptuiWizDigitalSignInfo
        {
            public IntPtr marshalPtr = IntPtr.Zero;
            private NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_INFO info;

            private NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO extendedInfo;
            private IntPtr extendedInfoPtr = IntPtr.Zero;

            private IntPtr exeFilenamePtr = IntPtr.Zero;

            public CryptuiWizDigitalSignInfo(string exeFilename, X509Certificate2 signingCertificate, string timestampUrl)
            {
                try
                {
                    extendedInfo = new NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO()
                    {
                        dwSize = (uint)Marshal.SizeOf(typeof(NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO)),
                        dwAttrFlags = 0,
                        pwszDescription = null,
                        pwszMoreInfoLocation = null,
                        pszHashAlg = null, // defaults to sha-1
                        pwszSigningCertDisplayString = null,
                        hAdditionalCertStore = IntPtr.Zero,
                        psAuthenticated = IntPtr.Zero,
                        psUnauthenticated = IntPtr.Zero,
                    };

                    extendedInfoPtr = Marshal.AllocHGlobal((int)extendedInfo.dwSize);
                    Marshal.StructureToPtr(extendedInfo, extendedInfoPtr, false);

                    exeFilenamePtr = Marshal.StringToHGlobalUni(exeFilename);

                    info = new NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_INFO()
                    {
                        dwSize = (uint)Marshal.SizeOf(typeof(NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_INFO)),
                        dwSubjectChoice = NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_INFO.CryptUIWizToSign.CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE,
                        Subject = exeFilenamePtr,
                        dwSigningCertChoice = NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_INFO.CryptUIWizSignLoc.CRYPTUI_WIZ_DIGITAL_SIGN_CERT,
                        pSigningCertObject = signingCertificate.Handle,
                        pwszTimestampURL = timestampUrl,
                        dwAdditionalCertChoice = NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_INFO.CryptUIWizAddChoice.CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN,
                        pSignExtInfo = extendedInfoPtr,
                    };

                    marshalPtr = Marshal.AllocHGlobal((int)info.dwSize);
                    Marshal.StructureToPtr(info, marshalPtr, false);
                }
                catch
                {
                    FreeMemory();
                    throw;
                }
            }

            public void FreeMemory()
            {
                if (extendedInfoPtr != IntPtr.Zero)
                {
                    Marshal.FreeHGlobal(extendedInfoPtr);
                    extendedInfoPtr = IntPtr.Zero;
                }

                if (exeFilenamePtr != IntPtr.Zero)
                {
                    Marshal.FreeHGlobal(exeFilenamePtr);
                    exeFilenamePtr = IntPtr.Zero;
                }

                if (marshalPtr != IntPtr.Zero)
                {
                    Marshal.FreeHGlobal(marshalPtr);
                    marshalPtr = IntPtr.Zero;
                }
            }
        }

        public static void Sign(string exeFilename, X509Certificate2 signingCertificate, string timestampUrl)
        {
            //timestampUrl must be Authenticode timestamp server like http://timestamp.digicert.com

            var CryptuiWizDigitalSignInfo = new CryptuiWizDigitalSignInfo(exeFilename, signingCertificate, timestampUrl);
            try
            {
                IntPtr context = IntPtr.Zero;
                try
                {
                    // Sign exe
                    if (!NativeMethods.CryptUIWizDigitalSign(NativeMethods.CryptUIWizFlags.CRYPTUI_WIZ_NO_UI, IntPtr.Zero, null, CryptuiWizDigitalSignInfo.marshalPtr, out context))
                        throw new Win32Exception(Marshal.GetLastWin32Error());
                }
                finally
                {
                    // Free pSignContext
                    if (context != IntPtr.Zero)
                    {
                        NativeMethods.CryptUIWizFreeDigitalSignContext(context);
                    }
                }
            }
            finally
            {
                CryptuiWizDigitalSignInfo.FreeMemory();
            }
        }
    }
}
