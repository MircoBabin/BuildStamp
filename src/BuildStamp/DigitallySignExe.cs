using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Cryptography.X509Certificates;

namespace BuildStamp
{
    public class DigitallySignExe
    {
        private static class NativeMethods
        {
            /* Partially copied from https://github.com/dahall/Vanara
             * https://github.com/dahall/Vanara/blob/master/PInvoke/Cryptography/CryptUI/Wincrypt.cs
               MIT License

               Copyright (c) 2017 David Hall

               Permission is hereby granted, free of charge, to any person obtaining a copy
               of this software and associated documentation files (the "Software"), to deal
               in the Software without restriction, including without limitation the rights
               to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
               copies of the Software, and to permit persons to whom the Software is
               furnished to do so, subject to the following conditions:

               The above copyright notice and this permission notice shall be included in all
               copies or substantial portions of the Software.

               THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
               IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
               FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
               AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
               LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
               OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
               SOFTWARE.
             */

            [Flags]
            public enum CryptUIWizFlags : uint
            {
                /// <summary>
                /// This function will sign the document based on the information in the CRYPTUI_WIZ_DIGITAL_SIGN_INFO structure pointed to by
                /// the pDigitalSignInfo parameter without displaying any user interface. If this flag is not specified, this function will
                /// display a wizard to guide the user through the signing process.
                /// </summary>
                CRYPTUI_WIZ_NO_UI = 0x0001,

                /// <summary>
                /// Suppress all user interfaces generated by cryptographic service providers (CSPs). This option can be overridden by the
                /// CRYPTUI_WIZ_NO_UI_EXCEPT_CSP option.
                /// </summary>
                CRYPTUI_WIZ_IGNORE_NO_UI_FLAG_FOR_CSPS = 0x0002,

                /// <summary>
                /// Suppress all user interfaces except those generated by CSPs. This option overrides the
                /// CRYPTUI_WIZ_IGNORE_NO_UI_FLAG_FOR_CSPS option.
                /// </summary>
                CRYPTUI_WIZ_NO_UI_EXCEPT_CSP = 0x0003,

                /// <summary>Skip the Export Private Key page and assume that the private key is to be exported.</summary>
                CRYPTUI_WIZ_EXPORT_PRIVATE_KEY = 0x0100,

                /// <summary>Disable the Delete the private key check box in the Export File Format page.</summary>
                CRYPTUI_WIZ_EXPORT_NO_DELETE_PRIVATE_KEY = 0x0200,

                /// <summary>Allow certificates to be imported.</summary>
                CRYPTUI_WIZ_IMPORT_ALLOW_CERT = 0x00020000,

                /// <summary>Allow CRLs to be imported.</summary>
                CRYPTUI_WIZ_IMPORT_ALLOW_CRL = 0x00040000,

                /// <summary>Allow CTLs to be imported.</summary>
                CRYPTUI_WIZ_IMPORT_ALLOW_CTL = 0x00080000,

                /// <summary>Do not allow the user to change the destination certificate store represented by the hDestCertStore parameter.</summary>
                CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE = 0x00010000,

                /// <summary>
                /// Import the object to the certificate store for the local computer. This applies only to Personal Information Exchange (PFX) imports.
                /// </summary>
                CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE = 0x00100000,

                /// <summary>Import the object to the certificate store for the current user. This applies only to PFX imports.</summary>
                CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER = 0x00200000,

                /// <summary>
                /// Import the object to a remote certificate store. Set this flag if the hDestCertStore parameter represents a remote
                /// certificate store.
                /// </summary>
                CRYPTUI_WIZ_IMPORT_REMOTE_DEST_STORE = 0x00400000,
            }

            [Flags]
            public enum CryptUIWizSigType
            {
                /// <summary>The signature is a commercial signature.</summary>
                CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL = 0x01,

                /// <summary>The signature is a personal signature.</summary>
                CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL = 0x02,
            }

            [StructLayout(LayoutKind.Sequential)]
            public struct CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO
            {
                /// <summary>The size, in bytes, of the structure.</summary>
                public uint dwSize;

                /// <summary>
                /// <para>A value that indicates the type of the signature.</para>
                /// </summary>
                public CryptUIWizSigType dwAttrFlags;

                /// <summary>A pointer to a null-terminated Unicode string that contains the description of the subject of the signature.</summary>
                [MarshalAs(UnmanagedType.LPWStr)] public string pwszDescription;

                /// <summary>
                /// A pointer to a null-terminated Unicode string that contains the location from which to get more information about the file.
                /// This information will be displayed when the file is downloaded.
                /// </summary>
                [MarshalAs(UnmanagedType.LPWStr)] public string pwszMoreInfoLocation;

                /// <summary>
                /// A pointer to a null-terminated ANSI string that contains the object identifier (OID) of the hash algorithm used for the
                /// signature. The default value is <c>NULL</c>, which indicates that the SHA-1 hash algorithm is used.
                /// </summary>
                [MarshalAs(UnmanagedType.LPStr)] public string pszHashAlg;

                /// <summary>
                /// A pointer to a null-terminated Unicode string that contains the string displayed on the digital signature wizard page. The
                /// string should prompt the user to select a certificate for a specific purpose.
                /// </summary>
                [MarshalAs(UnmanagedType.LPWStr)] public string pwszSigningCertDisplayString;

                /// <summary>A handle to an additional certificate store that will be added to the signature.</summary>
                public IntPtr hAdditionalCertStore;

                /// <summary>A pointer to a CRYPT_ATTRIBUTES structure that contains authenticated attributes supplied by the user.</summary>
                public IntPtr psAuthenticated;

                /// <summary>A pointer to a CRYPT_ATTRIBUTES structure that contains unauthenticated attributes supplied by the user.</summary>
                public IntPtr psUnauthenticated;
            }

            [StructLayout(LayoutKind.Sequential)]
            public struct CRYPTUI_WIZ_DIGITAL_SIGN_INFO
            {
                public UInt32 dwSize;

                public CryptUIWizToSign dwSubjectChoice;
                public enum CryptUIWizToSign : UInt32
                {
                    /// <summary>The user will be prompted for a file to sign.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_PROMPT = 0,

                    /// <summary>The memory BLOB specified by the pSignBlobInfo member is to be signed.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE = 0x01,

                    /// <summary>The file specified by the pwszFileName member is to be signed.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB = 0x02,
                }

                public CRYPTUI_WIZ_DIGITAL_SIGN_INFO_UNION ToSign;
                [StructLayout(LayoutKind.Explicit)]
                public struct CRYPTUI_WIZ_DIGITAL_SIGN_INFO_UNION
                {
                    /// <summary>
                    /// A pointer to a null-terminated Unicode string that contains the path and file name of the file to sign. This member is
                    /// used if <c>CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE</c> is specified for the <c>dwSubjectChoice</c> member.
                    /// </summary>
                    [FieldOffset(0)]
                    [MarshalAs(UnmanagedType.LPWStr)]
                    public string pwszFileName;

                    /// <summary>
                    /// A pointer to a CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO structure that contains the BLOB to sign. This member is used if
                    /// <c>CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB</c> is specified for the <c>dwSubjectChoice</c> member.
                    /// </summary>
                    //[FieldOffset(0)]
                    //public IntPtr pSignBlobInfo;
                }

                public CryptUIWizSignLoc dwSigningCertChoice;
                public enum CryptUIWizSignLoc : UInt32
                {
                    /// <summary>The certificates in the My store are used.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_USE_MY_STORE = 0x0,

                    /// <summary>The certificate is contained in the CERT_CONTEXT structure pointed to by the pSigningCertContext member.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_CERT = 0x01,

                    /// <summary>
                    /// The certificate is contained in the certificate store contained in the CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO structure pointed
                    /// to by the pSigningCertStore member.
                    /// </summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_STORE = 0x02,

                    /// <summary>
                    /// The certificate is contained in the PVK file contained in the CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO structure pointed to by
                    /// the pSigningCertPvkInfo member.
                    /// </summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_PVK = 0x03,
                }

                public IntPtr pSigningCertObject;

                [MarshalAs(UnmanagedType.LPWStr)]
                public string pwszTimestampURL;

                public CryptUIWizAddChoice dwAdditionalCertChoice;
                public enum CryptUIWizAddChoice
                {
                    /// <summary>No additional certificates will be included in the signature.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_ADD_NONE = 0x0,

                    /// <summary>The entire certificate chain will be included in the signature.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN = 0x00000001,

                    /// <summary>All certificates in the certificate chain except the root will be included in the signature.</summary>
                    CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT = 0x00000002,
                }

                /// <summary>
                /// A pointer to a CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO structure that contains extended information about the signature.
                /// </summary>
                public IntPtr pSignExtInfo;
            }

            [StructLayout(LayoutKind.Sequential)]
            public struct CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT
            {
                /// <summary>The size, in bytes, of the structure.</summary>
                public UInt32 dwSize;

                /// <summary>The size, in bytes, of the BLOB pointed to by the <c>pbBlob</c> member.</summary>
                public UInt32 cbBlob;

                /// <summary>A pointer to the signed BLOB.</summary>
                public IntPtr pbBlob;
            }

            [DllImport("Cryptui.dll", CharSet = CharSet.Unicode, SetLastError = true, ExactSpelling = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool CryptUIWizDigitalSign(CryptUIWizFlags dwFlags, [In, Optional] IntPtr hwndParent, [Optional, MarshalAs(UnmanagedType.LPWStr)] string pwszWizardTitle,
                        in CRYPTUI_WIZ_DIGITAL_SIGN_INFO pDigitalSignInfo, out IntPtr ppSignContext);

            [DllImport("Cryptui.dll", CharSet = CharSet.Unicode, SetLastError = true, ExactSpelling = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool CryptUIWizFreeDigitalSignContext(IntPtr pSignContext);
        }

        public static X509Certificate2 LoadCertificate(string pfxFilename, string pfxPassword)
        {
            return new X509Certificate2(pfxFilename, pfxPassword);
        }

        public enum SignWith { Sha1, Sha256 }
        public static byte[] Sign(string exeFilename, X509Certificate2 signingCertificate, SignWith hash, string timestampUrl)
        {
            //timestampUrl must be Authenticode timestamp like http://timestamp.comodoca.com

            //RFC 3161 timestamp like http://timestamp.comodoca.com/?td=sha256 will not work with CryptUIWizDigitalSign().
            //This will give an Exception "Unknown error (0xc000a000)"

            //Replaces existing digital signatures with this one.
            //Is unsuitable for dual digitally signing with both sha-1 and sha-256.

            NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_INFO digitalSignInfo;
            NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO digitalSignExtendedInfo;
            IntPtr pDigitalSignExtendedInfo;
            NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT signContext;

            digitalSignExtendedInfo = new NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO();
            digitalSignExtendedInfo.dwSize = (UInt32)Marshal.SizeOf(digitalSignExtendedInfo);
            digitalSignExtendedInfo.dwAttrFlags = 0;
            digitalSignExtendedInfo.pwszDescription = null;
            digitalSignExtendedInfo.pwszMoreInfoLocation = null;
            switch(hash)
            {
                case SignWith.Sha1:
                    digitalSignExtendedInfo.pszHashAlg = null; // defaults to sha-1
                    break;

                case SignWith.Sha256:
                    digitalSignExtendedInfo.pszHashAlg = "2.16.840.1.101.3.4.2.1"; // szOID_NIST_sha256 - OID for sha256
                    break;

                default:
                    throw new Exception("Unknown SignWith: " + hash.ToString());
            }
            digitalSignExtendedInfo.pwszSigningCertDisplayString = null;
            digitalSignExtendedInfo.hAdditionalCertStore = IntPtr.Zero;
            digitalSignExtendedInfo.psAuthenticated = IntPtr.Zero;
            digitalSignExtendedInfo.psUnauthenticated = IntPtr.Zero;

            pDigitalSignExtendedInfo = Marshal.AllocCoTaskMem(Marshal.SizeOf(digitalSignExtendedInfo));
            try
            {
                Marshal.StructureToPtr(digitalSignExtendedInfo, pDigitalSignExtendedInfo, false);

                digitalSignInfo = new NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_INFO();
                digitalSignInfo.dwSize = (UInt32)Marshal.SizeOf(digitalSignInfo);
                digitalSignInfo.dwSubjectChoice = NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_INFO.CryptUIWizToSign.CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE;
                digitalSignInfo.ToSign.pwszFileName = exeFilename;
                digitalSignInfo.dwSigningCertChoice = NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_INFO.CryptUIWizSignLoc.CRYPTUI_WIZ_DIGITAL_SIGN_CERT;
                digitalSignInfo.pSigningCertObject = signingCertificate.Handle;
                digitalSignInfo.pwszTimestampURL = (!string.IsNullOrWhiteSpace(timestampUrl) ? timestampUrl : null);
                digitalSignInfo.dwAdditionalCertChoice = 0; // NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_INFO.CryptUIWizAddChoice.CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN;
                digitalSignInfo.pSignExtInfo = pDigitalSignExtendedInfo;

                IntPtr pSignContext = IntPtr.Zero;
                try
                {
                    // Sign exe
                    if (!NativeMethods.CryptUIWizDigitalSign(NativeMethods.CryptUIWizFlags.CRYPTUI_WIZ_NO_UI, IntPtr.Zero, null, digitalSignInfo, out pSignContext))
                        throw new Win32Exception(Marshal.GetLastWin32Error());

                    // Get the blob with the signature
                    signContext = (NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT)Marshal.PtrToStructure(pSignContext, typeof(NativeMethods.CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT));

                    byte[] signatureBlob = new byte[signContext.cbBlob];
                    Marshal.Copy(signContext.pbBlob, signatureBlob, 0, (int)signContext.cbBlob);

                    return signatureBlob;
                }
                finally
                {
                    // Free pSignContext
                    if (pSignContext != IntPtr.Zero)
                        if (!NativeMethods.CryptUIWizFreeDigitalSignContext(pSignContext))
                            throw new Win32Exception(Marshal.GetLastWin32Error());
                }
            }
            finally
            {
                Marshal.FreeCoTaskMem(pDigitalSignExtendedInfo);
            }
        }
    }
}
